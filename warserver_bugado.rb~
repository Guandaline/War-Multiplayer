#encoding: utf-8

#yaml_obj = YAML::dump(env)
#File.open('on_message','w+') { |f| f.write (yaml_obj) }

require 'cgi'
#require 'yaml'
require 'json'

class WarServer < Rack::WebSocket::Application
  
  attr_reader :sid
  
  def initialize(opts = {}) #chamado quando servidor é estartado.
    super #super sempre deve ser chamado primeiro
    @@app ||= WarChat.new
    @sid = nil
  end
  
  def on_open(env) #chamado quando uma conexão é aberta
    puts '==='
    @sid = env['rack.session.options'][:id]
    @app.new_conn(self)
    puts '...'
  end
  
  def on_close(env) #chamado quando uma conexão é fechada
    @app.closed_conn(self)
  end
  
  def on_message(env,msg) #chamado quando recebe um mensagem
    @app.message_received(self,msg)      
  end
  
  def on_error(env, error) #chamado quando um erro acontece
    puts "<<ERRO>> " << error.message
  end
  
  def send_msg(msg,escape=true)
    msg = CGI.escapeHTML(msg) if escape
    send_data(msg);
  end
end



class WarChat

  def initialize
    @persons = []
    puts 'Aplicacao WarChat iniciada...'
  end
  
  def new_conn(conn)
    puts 'Nova conexao: ' + conn.sid
  end
  
  def closed_conn(conn)
  end
  
  def message_received(conn,msg)
    msg = JSON.parse(msg)
    add_person(conn.sid,msg['nick']) if msg['type'] == 'init'
  end  
  
  private
  def add_person(sid,nick)
    @persons.push(Person.new(sid,nick))
    #aqui fazer broadcast avisando todo mundo que alguem entrou
  end
  
end

class Person
  attr_reader :sid, :nick

  def initialize(sid=nil,nick=nil)
    @sid = sid
    @nick = nick
  end
end

class Message
  attr_reader :type
  #tipos de mensagem -> :init, :text, :warn, :error 
end

class InitMessage < Message
  def initialize
    @type = :init    
  end
end
